#!/bin/zsh

# API供应商环境切换工具
# 版本: 2.0
# 支持配置文件驱动的供应商管理
# 
# 功能特性:
# - 配置文件驱动的供应商管理
# - OpenAI和Claude API支持
# - 环境变量冲突自动清理
# - 配置验证和错误处理
# - 状态查询和供应商列表
# - 安全的API密钥处理

# 配置文件路径
CONFIG_FILE="vendors.conf"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_PATH="${SCRIPT_DIR}/${CONFIG_FILE}"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 错误处理函数
error_exit() {
    echo -e "${RED}错误: $1${NC}" >&2
    echo -e "${YELLOW}解决方案: $2${NC}" >&2
    exit 1
}

# 成功消息函数
success_msg() {
    echo -e "${GREEN}✓ $1${NC}"
}

# 警告消息函数
warning_msg() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# 信息消息函数
info_msg() {
    echo -e "${BLUE}ℹ $1${NC}"
}

# 检查配置文件是否存在，不存在则创建模板
check_config_file() {
    if [[ ! -f "$CONFIG_PATH" ]]; then
        warning_msg "配置文件不存在，正在创建模板配置文件..."
        if ! create_template_config; then
            error_exit "无法创建配置文件" "检查目录权限并重试"
        fi
        info_msg "请编辑 $CONFIG_FILE 文件，添加你的API供应商配置"
        exit 0
    fi
    
    # 检查配置文件是否可读
    if [[ ! -r "$CONFIG_PATH" ]]; then
        error_exit "无法读取配置文件: $CONFIG_PATH" "检查文件权限"
    fi
}

# 创建模板配置文件
create_template_config() {
    cat > "$CONFIG_PATH" << 'EOF'
# API供应商配置文件
# 格式: [供应商名称]
#       type=openai|claude
#       api_key=你的API密钥
#       api_url=API基础URL
#       model=模型名称 (可选，仅OpenAI类型)

# OpenAI供应商配置示例
[openai-official]
type=openai
api_key=your_openai_official_api_key
api_url=https://api.openai.com
model=gpt-4

[deepseek]
type=openai
api_key=your_deepseek_api_key
api_url=https://api.deepseek.com
model=deepseek-chat

[zhipu]
type=openai
api_key=your_zhipu_api_key
api_url=https://open.bigmodel.cn/api/paas/v4
model=glm-4

# Claude供应商配置示例
[claude-official]
type=claude
api_key=your_claude_official_api_key
api_url=https://api.anthropic.com

[claude-proxy]
type=claude
api_key=your_claude_proxy_api_key
api_url=https://api.claude-proxy.com

# 向后兼容的供应商别名（兼容v1.0脚本）
[vendor1]
type=openai
api_key=your_vendor1_api_key
api_url=https://api.vendor1.com
model=gpt-3.5-turbo

[vendor2]
type=openai
api_key=your_vendor2_api_key
api_url=https://api.vendor2.com
model=gpt-4

[vendor3]
type=openai
api_key=your_vendor3_api_key
api_url=https://api.vendor3.com
model=gpt-4

[claude1]
type=claude
api_key=your_claude1_api_key
api_url=https://api.claude1.com

[claude2]
type=claude
api_key=your_claude2_api_key
api_url=https://api.claude2.com

# 添加更多供应商配置...
# [your-vendor-name]
# type=openai|claude
# api_key=your_api_key
# api_url=https://your.api.url
EOF
    
    # 设置安全的文件权限
    chmod 600 "$CONFIG_PATH"
    success_msg "已创建配置文件模板: $CONFIG_FILE"
}

# 显示使用帮助
show_help() {
    echo "API供应商环境切换工具 v2.0"
    echo ""
    echo "用法:"
    echo "  ./ai-env-manager <供应商名称>     切换到指定供应商"
    echo "  ./ai-env-manager --status        显示当前状态"
    echo "  ./ai-env-manager --list          列出所有可用供应商"
    echo "  ./ai-env-manager --help          显示此帮助信息"
    echo "  ./ai-env-manager --version       显示版本信息"
    echo ""
    echo "示例:"
    echo "  ./ai-env-manager openai-official"
    echo "  ./ai-env-manager claude-official"
    echo "  ./ai-env-manager --status"
    echo ""
    echo "配置文件: $CONFIG_FILE"
}

# 主函数 - 处理命令行参数
main() {
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "API供应商环境切换工具 v2.0"
            echo "兼容原始 switch_openai_env.sh 脚本"
            exit 0
            ;;
        --status|-s)
            check_config_file
            show_status
            exit 0
            ;;
        --list|-l)
            check_config_file
            list_vendors
            exit 0
            ;;
        "")
            show_help
            exit 1
            ;;
        *)
            check_config_file
            switch_vendor "$1"
            ;;
    esac
}

# 全局关联数组存储配置
typeset -A VENDOR_CONFIGS
CONFIG_PARSED=false

# 解析配置文件
parse_config() {
    # 如果已经解析过，直接返回
    if [[ "$CONFIG_PARSED" == "true" ]]; then
        return 0
    fi
    
    local current_section=""
    local line_num=0
    
    # 清空之前的配置
    VENDOR_CONFIGS=()
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        ((line_num++))
        
        # 去除行首尾空格
        line=$(echo "$line" | xargs)
        
        # 跳过空行和注释
        if [[ -z "$line" ]] || [[ "$line" == \#* ]]; then
            continue
        fi
        
        # 检测节标题 [vendor_name]
        if [[ "$line" == "["*"]" ]]; then
            current_section="${line#\[}"
            current_section="${current_section%\]}"
            continue
        fi
        
        # 解析键值对
        if [[ "$line" == *"="* ]]; then
            local key="${line%%=*}"
            local value="${line#*=}"
            
            # 去除键和值的首尾空格
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | xargs)
            
            if [[ -z "$current_section" ]]; then
                error_exit "配置错误：第 $line_num 行的键值对不在任何节中" "确保键值对位于 [供应商名称] 节中"
            fi
            
            # 存储配置到关联数组
            VENDOR_CONFIGS["${current_section}_${key}"]="$value"
        else
            error_exit "配置错误：第 $line_num 行格式无效: '$line'" "使用格式: key=value 或 [section_name]"
        fi
    done < "$CONFIG_PATH"
    
    # 标记配置已解析
    CONFIG_PARSED=true
}

# 验证供应商配置
validate_vendor_config() {
    local vendor="$1"
    local type=$(get_vendor_config "$vendor" "type")
    local api_key=$(get_vendor_config "$vendor" "api_key")
    local api_url=$(get_vendor_config "$vendor" "api_url")
    
    # 检查必填字段
    if [[ -z "$type" ]]; then
        error_exit "供应商 '$vendor' 缺少 type 字段" "在配置文件中添加: type=openai 或 type=claude"
    fi
    
    if [[ -z "$api_key" ]]; then
        error_exit "供应商 '$vendor' 缺少 api_key 字段" "在配置文件中添加: api_key=your_api_key"
    fi
    
    if [[ -z "$api_url" ]]; then
        error_exit "供应商 '$vendor' 缺少 api_url 字段" "在配置文件中添加: api_url=https://your.api.url"
    fi
    
    # 验证 type 字段
    if [[ "$type" != "openai" && "$type" != "claude" ]]; then
        error_exit "供应商 '$vendor' 的 type 字段无效: '$type'" "type 必须是 'openai' 或 'claude'"
    fi
    
    # 验证 URL 格式
    if [[ ! "$api_url" =~ ^https?://[a-zA-Z0-9.-]+[a-zA-Z0-9]+(:[0-9]+)?(/.*)?$ ]]; then
        error_exit "供应商 '$vendor' 的 api_url 格式无效: '$api_url'" "URL 必须是有效的 HTTP/HTTPS URL 格式"
    fi
    
    # 验证 API key 不为占位符
    if [[ "$api_key" =~ ^your_.*_api_key$ ]]; then
        warning_msg "供应商 '$vendor' 使用了占位符 API key，请替换为真实的 API key"
    fi
}

# 获取所有供应商列表
get_vendors() {
    local vendors=""
    for key in "${(k)VENDOR_CONFIGS[@]}"; do
        # 去除键名的引号
        key="${key//\"/}"
        if [[ "$key" == *"_type" ]]; then
            local vendor="${key%_type}"
            if [[ -n "$vendors" ]]; then
                vendors="$vendors\n$vendor"
            else
                vendors="$vendor"
            fi
        fi
    done
    if [[ -n "$vendors" ]]; then
        echo -e "$vendors" | sort -u
    fi
}

# 检查供应商是否存在
vendor_exists() {
    local vendor="$1"
    local key="${vendor}_type"
    # 检查键是否存在（即使值为空）
    [[ -v "VENDOR_CONFIGS[$key]" ]] || [[ -v "VENDOR_CONFIGS[\"$key\"]" ]]
}

# 获取供应商配置
get_vendor_config() {
    local vendor="$1"
    local field="$2"
    local key="${vendor}_${field}"
    # 尝试带引号和不带引号的键
    local value="${VENDOR_CONFIGS[$key]}"
    if [[ -z "$value" ]]; then
        value="${VENDOR_CONFIGS[\"$key\"]}"
    fi
    echo "$value"
}

# 列出所有可用供应商
list_vendors() {
    parse_config
    
    echo "可用的API供应商："
    echo ""
    
    local vendors_list=$(get_vendors)
    
    if [[ -z "$vendors_list" ]]; then
        warning_msg "配置文件中没有找到任何供应商配置"
        info_msg "请编辑 $CONFIG_FILE 文件添加供应商配置"
        return 1
    fi
    
    while IFS= read -r vendor; do
        [[ -z "$vendor" ]] && continue
        
        local type=$(get_vendor_config "$vendor" "type")
        local url=$(get_vendor_config "$vendor" "api_url")
        
        case "$type" in
            openai)
                echo -e "  ${GREEN}$vendor${NC} (OpenAI) - $url"
                ;;
            claude)
                echo -e "  ${BLUE}$vendor${NC} (Claude) - $url"
                ;;
            *)
                echo -e "  ${YELLOW}$vendor${NC} (未知类型: $type) - $url"
                ;;
        esac
    done <<< "$vendors_list"
    
    echo ""
    echo "使用方法: ./ai-env-manager <供应商名称>"
}

# 清理OpenAI环境变量
clear_openai_env() {
    unset OPENAI_API_KEY
    unset OPENAI_BASE_URL
    unset OPENAI_MODEL
}

# 清理Claude环境变量
clear_claude_env() {
    unset ANTHROPIC_AUTH_TOKEN
    unset ANTHROPIC_BASE_URL
}

# 设置OpenAI环境变量
set_openai_env() {
    local api_key="$1"
    local api_url="$2"
    local model="$3"
    
    # 清理Claude环境变量以避免冲突
    clear_claude_env
    
    export OPENAI_API_KEY="$api_key"
    export OPENAI_BASE_URL="$api_url"
    
    # 设置模型（如果提供）
    if [[ -n "$model" ]]; then
        export OPENAI_MODEL="$model"
    fi
}

# 设置Claude环境变量
set_claude_env() {
    local api_key="$1"
    local api_url="$2"
    
    # 清理OpenAI环境变量以避免冲突
    clear_openai_env
    
    export ANTHROPIC_AUTH_TOKEN="$api_key"
    export ANTHROPIC_BASE_URL="$api_url"
}

# 获取当前环境状态
get_current_env_status() {
    local env_status=""
    
    if [[ -n "$OPENAI_API_KEY" && -n "$OPENAI_BASE_URL" ]]; then
        env_status="openai:$OPENAI_BASE_URL"
    elif [[ -n "$ANTHROPIC_AUTH_TOKEN" && -n "$ANTHROPIC_BASE_URL" ]]; then
        env_status="claude:$ANTHROPIC_BASE_URL"
    else
        env_status="none"
    fi
    
    echo "$env_status"
}

# 显示当前状态
show_status() {
    local current_status=$(get_current_env_status)
    
    echo "当前API环境状态："
    echo ""
    
    case "$current_status" in
        openai:*)
            local url="${current_status#openai:}"
            echo -e "  类型: ${GREEN}OpenAI${NC}"
            echo -e "  Base URL: $url"
            echo -e "  API Key: ${GREEN}已设置${NC} (***隐藏***)"
            if [[ -n "$OPENAI_MODEL" ]]; then
                echo -e "  模型: ${GREEN}$OPENAI_MODEL${NC}"
            fi
            ;;
        claude:*)
            local url="${current_status#claude:}"
            echo -e "  类型: ${BLUE}Claude${NC}"
            echo -e "  Base URL: $url"
            echo -e "  Auth Token: ${GREEN}已设置${NC} (***隐藏***)"
            ;;
        none)
            echo -e "  ${YELLOW}未设置任何API环境变量${NC}"
            ;;
    esac
    
    echo ""
    echo "环境变量详情："
    echo "  OPENAI_API_KEY: ${OPENAI_API_KEY:+已设置}"
    echo "  OPENAI_BASE_URL: ${OPENAI_BASE_URL:-未设置}"
    echo "  OPENAI_MODEL: ${OPENAI_MODEL:-未设置}"
    echo "  ANTHROPIC_AUTH_TOKEN: ${ANTHROPIC_AUTH_TOKEN:+已设置}"
    echo "  ANTHROPIC_BASE_URL: ${ANTHROPIC_BASE_URL:-未设置}"
}

switch_vendor() {
    parse_config
    
    local vendor="$1"
    
    if ! vendor_exists "$vendor"; then
        error_exit "未知的供应商: '$vendor'" "使用 './ai-env-manager --list' 查看可用供应商"
    fi
    
    validate_vendor_config "$vendor"
    
    local type=$(get_vendor_config "$vendor" "type")
    local api_key=$(get_vendor_config "$vendor" "api_key")
    local api_url=$(get_vendor_config "$vendor" "api_url")
    local model=$(get_vendor_config "$vendor" "model")
    
    # 根据类型设置相应的环境变量
    case "$type" in
        openai)
            set_openai_env "$api_key" "$api_url" "$model"
            success_msg "已切换到 OpenAI 供应商: $vendor"
            ;;
        claude)
            set_claude_env "$api_key" "$api_url"
            success_msg "已切换到 Claude 供应商: $vendor"
            ;;
        *)
            error_exit "不支持的供应商类型: $type" "支持的类型: openai, claude"
            ;;
    esac
    
    echo ""
    echo "当前环境配置："
    echo "  Base URL: $api_url"
    echo "  API Key: ***隐藏***"
    if [[ "$type" == "openai" && -n "$model" ]]; then
        echo "  模型: $model"
    fi
    
    # 提示用户如何使用
    echo ""
    info_msg "环境变量已设置，你现在可以使用 $type API 了"
    info_msg "使用 './ai-env-manager --status' 查看当前状态"
    echo ""
    warning_msg "注意：要在当前shell中生效，请使用: source ./ai-env-manager $vendor"
    
    # 可选：显示性能信息
    if [[ "${DEBUG:-}" == "1" ]]; then
        info_msg "配置解析状态: $CONFIG_PARSED"
        info_msg "配置项数量: ${#VENDOR_CONFIGS[@]}"
    fi
}

# 执行主函数
main "$@"